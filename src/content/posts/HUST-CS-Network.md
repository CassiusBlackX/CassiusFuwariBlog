---
title: 计算机网络复习
published: 2024-12-12
description: '华中科技大学 计算机科学与技术学院 计算机网络复习'
image: ''
tags: ["HUST"]
category: notes
draft: false 
lang: ''
---
# 计算机网络和因特网
#### 什么是因特网
+ 因特网是世界范围的计算机网络
+ 因特网向是应用程序提供服务的基础设置，提供统一的套接字编程接口
#### 什么是协议
协议是指计算机之间通讯的语言，定义了网络实体之间鹰遵守的原则

### 网络边缘
#### 网络划分
+ 网络核心：
  + 路由器/交换机
  + 网络的网络
+ 网络边缘：
  + 主机：客户机/服务器
  + 位于数据中心的服务器

#### 网络边缘的组成
主机（端系统）：客户机 + 服务器

#### 网络边缘的作用
+ 让用户在端系统上运行各自的应用程序
+ 用户享受到因特网的各种服务

### 网络接入
#### 接入网
将网络边缘的端系统（主机）与网络连接起来的链路。

连接到哪里：将端系统连接到边缘路由器上

> 边缘路由器：端系统到任何其它远程端系统的路径上的第一台路由器

##### 端系统接入网络的方式
+ 点对点方式接入
  + 通过电话线
    + Modem拨号：通过本地电话线路点对点连接ISP拨号池（通常是路由器），理论最高56kbps，无法实现上网同时拨打电话
    + ADSL：不对称数字用户线。用调制解调器将数据调制成高音频信号。
  + 通过光纤到户
    + 光纤通过光调制解调器（光猫）将光电信号互相转换。电脑通过双绞线连接到光猫。
  + 通过卫星
+ 以太网/WiFi方式接入
+ 广域无线接入

## 分组交换与电路交换
+ 第一代计算机网络：电路交换网络
+ 第二代计算机网络：分组交换网络

### 电路交换网络
1. 数据交换过程
   1. 建立连接
   2. 交换数据
   3. 释放连接
2. 电路交换中的复用
   1. 时分复用TDM
   2. 频分复用FDM
3. 电路交换网络特性
   1. 数据交换前需建立起一条从发端到收端的物理通路
   2. 在数据交换的全部时间内用户始终占用端到端的固定传输信道
   3. 交换双方可实时进行数据交换而不会存在任何延迟
4. 问题
   1. 计算机之间的数据交换往往具有突发性和间歇性特征，而对电路交换而言，用户支付的费用是按用户占用线路的时间收费的
   2. 不够灵活。只要在童话双方建立的通路中的任何一点出了故障，就必须重新拨号建立新的连接，这对紧急和重要通信是很不利的

### 分组交换网络
1. 引入动机
   1. 专门用于计算机之间的数据传送
   2. 能够连接不同类型的计算机
   3. 所有的网络节点同等重要，不能有特别重要的节点
   4. 必须有冗余路由
   5. 网络结构尽可能简单，能够可靠传送数据
2. 工作流程
   1. 长数据切分成小段：在发送端，先把较长的报文划分成较短的、固定长度的数据段
   2. 生成分组：每一个数据段前面添加上首部构成分组
   3. 接收数据：接收端收到分组后剥去首部还原成报文
   4. 恢复报文
3. 分组首部的重要性
   1. 每一个分组的首部都包含有地址等控制信息
   2. 节点交换机必须根据首部中的地址信息，选则路由，把分组转发到下一个节点交换机
   3. 没有这些信息，就不知道该往哪里转发分组，也就到不了最终目的地
4. 特征
   1. 被传送的数据分成若干分组分别传送
   2. 数据传输前不必预先确定分组的传输路径
   3. 网络核心中每个交换节点均为共享节点
   4. 数据传输采用存储/转发模式
   5. 各节点具有选则合适路由的能力
   + 网络核心断续（动态）分配传输带宽，使得通信线路的利用率得以大大提高
   + 网络核心常采用网状拓扑结构，降低拥塞活故障时的影响

#### 分组交换网络的分类
+ 数据报网络
  + 完全按照分组交换网络的原理进行工作（纯分组交换）
    + 按照分组内的目的地址路由
    + 在会话过程中路由可能改变
+ 虚电路网络：为了获得一些电路交换的有点，在分组交换网上模拟一些电路交换的特点
  + 虚电路需要建立连接，即建立虚电路链路
  + 在建立连接时决定链路的路由，在整个连接过程中保持不变
  + 在链路通过的每个节点，预留一定的资源
  + 每个分组携带一个标识（虚电路号），根据该标识知道该从哪个虚电路传输数据
  + 虚电路如果不使用了，需要释放相关的资源

### 分组交换VS电路交换
+ 在相同条件下，分组交换能够比电路交换支持更多的用户
+ 当用户数较少时，分组交换能够获得比电路交换更好的性能
+ 在数据量大时，分组交换的传输时延比电路交换大（分组交换在节点之间传输数据的时候，每个节点都必须要完整收到数据报文才能够把数据报文重新切分而发出去）
  + 分组在各节点存储转发时因要排队，总会造成一定的时延。当网络通信量过大时，这种时延可能会很大
  + 各分组必须携带一定的控制信息（说明信息），从而带来额外开销
  + ==> 整个分组交换网的管理和控制比较复杂

+ 若要连续传送大量数据，且其传送时间远大于呼叫建立时间，则采用在数据通信之前预先分配传输带宽的电路交换比较合适
+ 分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率

## 网络核心
网络核心的主要任务：将数据从一个网络传输到远方的另一个网络

## 时延、丢包和吞吐量
### 数据丢失和产生时延的原因
+ 数据不断从设备推送到网络上，需要花费一定的时间，推送的速度收到网络带宽的影响
+ 数据不断从链路的一端传送到链路的另一端，需要花费一定的时间，传送速度收到电子传送速度影响
+ 设备接收数据以及决定往哪里转发数据，需要花费一定的时间，处理时间受设备硬件的影响
+ 路由器接收到的数据需要排队以便按顺序转发和调节接收与转发速度的不一致，排队需要花费一些时间，排队时间受设备硬件的影响
+ 当数据队列已满时，再收到的数据只能丢掉
+ 当报文网络中传输，路由形成了环路，无法传送到目标节点时，这个报文也只能丢掉

### 四种分组时延
+ 总时延：
  + 处理时延
  + 排队时延
  + 传输时延
  + 传播时延

+ 排队时延分析：
  + R=链路带宽(bps), L=分组长度(bites), a=平均分组到达速率
  + 流量强度: $\frac{La}{R}$
    + $\frac{La}{R}$ ~ 0: 平均排队时延很小，甚至为0
    + $\frac{La}{R} < 1$: 时延较小，且会随时间推延而变小
    + $\frac{La}{R} = 1$: 时延不会变化，具体数值取决于当时队列长度
    + $\frac{La}{R} > 1$: 平均时延较大，且随时间推延而趋于无穷

+ 吞吐量
  + 在发送方与接收方之间传输比特的速率
  + 瓶颈链路：在端到端路径上限制了端到端平均吞吐量的一段链路

## 层次化的网络体系结构
+ 协议层次结构的好处
  + 协议之间的调用关系明确
  + 模块化简化了系统的维护和升级
    + 某个层次服务实现的改变对系统的其余部分是透明的
+ 分层的做法的不完善处
  + 不是所有协议关系都能够归结为两层之间
  + 偶尔会出现
    + 隔层调用服务的想想
    + 或者下层调用上层的现象

+ 基本概念
  + 实体(entity): 实体是任何可以发送和接收信息的硬件和软件进程。通常是一个特定的软件模块
  + 对等体(peer): 不同机器上包含对应层的实体成为对等体
  + 服务(service): 为保证上层对等体之间能互相通信，下层向上层提供的功能
  + 接口(interface): 接口位于每对相邻层之间，定义了下层向上层提供的原语操作和服务
  + 协议数据单元(PDU): 协议数据单元是对等层次上传送数据的单位
  + 服务数据单元(SDU): 服务数据单元是层与层之间交换数据的单位
  + 网络体系结构(network architecture): 网络体系结构就是层和协议的集合
  + 协议栈(protocol stack): 一个特定的系统所使用的一系列协议（每层一组协议）

### 网络体系结构模型介绍
+ 因特网5层模型（协议栈）
  + 应用层
    + 支持网络应用
  + 运输层
    + 不同主机上进程间的数据传输
  + 网络层
    + 主机间的数据通信
  + 链路层
    + 数据在网络相邻节点之间传输
  + 物理层
    + 在线路上传输比特流
+ ISO的7层模型（OSI）
  + 应用层
  + 表示层
    + 数据的含义、描述等统一的表示
  + 会话层
    + 数据交换的同步、定界、建立检查点和恢复的能力
  + 运输层
  + 网络层
  + 链路层
  + 物理层

+ 报文封装
  + 应用层：报文 
  + 运输层：报文段
  + 网络层：数据报
  + 链路层：帧

### 因特网中复用和分解
+ 常用的集中复用技术
  + 针对应用进程
    + 套接字
  + 针对电路层
    + 频分复用
    + 时分复用
    + 码分多址

### 数据差错的检查方法
+ 常用检查报文出错的方法：
  + 奇偶校验
  + 检查和
  + 循环冗余校验码

# 应用层
## 应用层协议原理
+ 网络应用之间通信所采用的体系架构
  + 客户机/服务器体系架构(C/S)
    + 存在一个能够向客户机提供服务的服务器
    + 存在一个或多个主动连接服务器，试图从服务器那里获得所需服务的客户机
    + 注意：
      + 客户机之间不能互相通信
      + 为提高服务器的处理能力，通常采用服务器集群
  + P2P体系架构
    + 任何一方既提供服务又享受服务
    + 节点之间可以直接通信
    + 节点的地址以及他们之间的连接可能随时发生变化
    + 特点：容易扩展，但是特别难以管理
  + 混合体系架构

应用层协议不等于网络应用
+ 应用层协议定义了
  + 交换的报文类型
  + 各种报文类型的语法
  + 字段的语义
  + 进程何时、如何发送报文及对应报文进行相应

+ TCP
  + 面向连接：在客户端和服务器进程之间需要建立连接
  + 可靠传输：在发送和接收进程之间
  + 流量控制：发送数据的速度绝对不超过接收的速度
  + 拥塞控制：当网络超负荷时，束紧发送端口，减缓发送速度
  + 不提供：实时性，最小带宽承诺
+ UDP
  + 在客户端和服务器进程之间实现“不可靠”数据传输
  + 不提供：连接建立，可靠性保证，流量控制，拥塞控制，实时性，最小带宽承诺
+ 安全性
  + TCP/UDP天生不具备安全性
  + 安全套接字层SSL
    + 提供加密的TCP连接
    + 数据的完整性检查
    + 端点身份鉴别
    + SSL位于应用层与TCP之间
  
+ 套接字
  + 每个网络应用进程都有一个属于自己的套接字，该套接字在整个因特网上独一无二
  + 主机地址：表示该网络应用进程运行在因特网上哪一台主机上，通常使用32位的IP地址进行标识
  + 端口地址：在该主机上标识该网络应用进程，通常使用16位的端口号进行标识
  + 所以套接字的长度为48位
  + 进程通过套接字来接收和发送报文
  + 套接字相当于一个通道
    + 发送进程将报文交给套接字
    + 套接字将这些报文传输到接收进程的套接字

## web和HTTP
### Web
+ WEB的内容表达
  + web页面由一些对象组成
  + 对象可以是HTML, JPEG, 音频文件, JAVA APPLET
  + HTML文件是web页面的基础，它可以包括各种各样的对象，是一个容器对下个
  + 任何一个对象都可以用URL来定位
+ WEB的内容传输
  + 客户端/服务器模式
    + 客户端：浏览器请求、接收、展示web对象
    + 服务器：web服务器发送对象，对请求进行响应
  + http: TCP传输服务
    + 客户端启动TCP连接（创建套接字）到服务器，端口80
    + 服务器接受来自客户端的TCP连接
    + http报文（应用层协议报文）在浏览器(http client)和web服务器(http server)之间进行性交换
    + 关闭TCP连接

### HTTP
+ HTTP1.0 非持久性连接
  + 每传输一个文件都需要建立连接-请求文件-收到文件
+ HTTP1.1 持久连接
  + 服务器在发送响应后，不再断开TCP连接，而是保持该连接，用于后续对象的传送，直至该连接“休息”了一个较长的时间后，方断开连接
  + 减少了对服务器端连接数的要求，从而减少了对服务器端套架子资源的占用，提高了服务器的负载能力
  + 分类：
    + 非流水线方式：一个对象传输完方能传输下一个
    + 流水线方式：可以一次性发送所有请求，慢慢接收
  + 存在的问题：
    + 存在多个对象时，晓对象会被排在前面的大对象阻塞——队首(HOL)阻塞——用户体验极差
    + 多TCP连接并发可以规避这个问题——回到了HTTP/1.0
+ HTTP/2
  + 目标：减少多对象访问时的感知延迟
    + 方案：
      + 方法、状态短码和大多数首部字段与HTTP1.1相同
      + 根据客户指定的对象优先级（不一定是FCFS）确定请求对象的传输顺序
      + 将未请求的对象推送给客户端——服务器推
      + 将对象划分为帧，对帧的传输进行规划以减少HOL阻塞
+ HTTP/3
  + TCP+TLS换成UDP+QUIC,准确来说是通过 (HTTP over QUIC)+QUIC+UDP
  + 相比之下，HTTP/2的实现方式是HTTP/2+TLS+TCP

+ HTTP报文类型：请求报文&响应报文
+ 请求行支持的方法
  + GET: 向服务器请求指定URL对象
  + POST: 用于向服务器提交表单数据，也可以同时请求一个WEB页面
  + HEAD: 返回响应报文，不包含请求的对象
  + PUT: 山川的文件放在实体主题字段中，目标路径由URL字段标明
  + DELETE: 删除URL字段中指定的文件
+ 常见的响应状态码和短语
  + 200 OK: 请求成功，被请求的对象在报文中
  + 301 Moved Permanently: 被请求的对象被移动过，新的位置在报文中有说明
  + 400 Bad Request: 服务器不懂请求报文
  + 404 Not Found: 服务器上找不到请求的对象
  + 505 HTTP Version Not Supported: 服务器不支持请求报文使用的HTTP协议版本

+ 用户-服务器交互：cookie
  + web站点使用cookie的目的
    + 限制用户的访问
    + 把内容和用户身份关联起来
  + cookie技术的组成部分
    + 在HTTP响应报文中有一个cookie首部行
    + 在HTTP请求报文中也有一个cookie首部行
    + 在用户的端系统中保留了一个cookie文件，由用户浏览器负责管理
    + 在web站点有一个后端数据库

## 因特网中的电子邮件
### 电子邮件系统的构成
+ 用户代理
  + 写作，编辑，阅读邮件报文
+ 邮件服务器
  + 邮箱：包含了收到的用户邮件（尚未被阅读）
  + 报文：队列包含了外发的邮件报文
+ 简单邮件传输协议: SMTP
  + SMTP协议用在邮件服务器之间发送邮件
  + 客户端：将邮件发送到邮件服务器
  + 服务器：接收和转发邮件

#### SMTP协议
+ 使用TCP可靠的传送邮件报文，端口25
+ 直接传输：发送服务器到接收服务器
  + 传输三个阶段
    + 握手
    + 报文传输
    + 结束
  + 命令/响应交互：
    + 命令：ASCII文本
    + 响应：状态码和短语
+ 邮件报文必须使用7-bit ASCII表示
+ SMTP使用持续连接
+ 某些代码组合不允许出现在报文中(e.g., CRLF.CRLF),此类数据必须进行编码（通常使用base-64或quoted printable）
+ SMTP服务器用CRLF.CRLF表示邮件报文的结束

+ SMTP vs HTTP
  + 都使用ASCII命令/响应交互，状态码
  + HTTP: pull; SMTP: push
  + HTTP协议不限制报文编码格式，SMTP协议要求报文必须使用7-bit ASCII码格式
  + HTTP: 每个对象分装在各自的响应报文中；SMTP: 多个对象在一个多分布的报文中传送

+ 客户机获取邮件的方法
  + POP3协议
    + 命令行
      + list: 列出报文号码
      + retr: 用报文号码取信
      + dele: 用报文号码删信
      + quit
    + 功能：
      + “下载-删除”：用户如果更换客户机无法再次阅读原来的邮件
      + “下载-保存”：在不同的客户机上保存邮件的副本
    + POP3会话是没有状态的
    + 用户使用POP3协议无法在邮件服务器上对自己的邮件进行重组织，只能将邮件下载到本地计算机进行重组织
  + IMAP协议
    + 将所有的邮件都保存在服务器上
    + 允许用户在服务器上组织自己的邮件目录
    + IMAP维护了IMAP会话的用户信息
      + 目录名以及报文ID与目录名之间的映射关系
  + HTTP

## DNS: 因特网的目录服务
+ DNS简况
  + DNS是一个分布式数据库，由很多DNS服务器按层次结构组织起来
  + DNS运行在一个端到端系统上，且使用UDP协议(53号端口)进行报文传输，因此DNS是应用层协议
  + DNS以C/S模式工作
  + DNS不直接和用户打交道，是因特网的核心功能
+ 一次最简单的DNS解析过程
  + 浏览器输出www.hust.edu.cn/index.html链接，从该链接中取出www.hust.edu.cn部分，发送给DNS客户机
  + DNS客户机向DNS服务器发送包含域名www.hust.edu.cn的查询请求报文
  + DNS服务器向DNS客户机返回一个包含对应IP地址的响应报文
  + DNS客户机将获得的IP地址传送给浏览器
  + 浏览器向IP地址所在WEB服务器发起TCP链接

### 域名系统名字空间和层次结构
+ Internet的域名结构
  + Internet的域名结构采用了层次树状结构的明明方法
  + 域名的结构由若干分量组成，各分量之间用小数点隔开，总长不超过255个字符
  + 各分量分别代表不同级别的域名（不超过63字符）
  + 合法域名中，小数点的个数至少为一个
+ 顶级域名(TLD Top Level Domain)一般有三类
  + 国家或地区顶级域名nTLD,也记作ccTLD
  + 基础设施域 .arpa(Address and Routing Parameter Area)
    + 专用于Internet基础设施目的
  + 通用顶级域名gTLD

+ 跟DNS服务器-权威DNS服务器-本地DNS服务器
+ 严格来说，本地DNS服务器并不属于DNS层次结构中的一层

### DNS解析的过程
+ DNS解析过程：递归+迭代 VS 纯递归
+ 递归+迭代的对服务器的负载压力会比较小。

+ 递归+迭代
  + 本地DNS服务器通过根DNS服务器获取需要解析的地址的顶级域名的相关信息
  + 本地DNS服务器根据获取的顶级域名相关信息，去对应的顶级域名服务器获取权威DNS服务器的相关信息
  + 本地DNS服务器根据获取的权威DNS服务器的相关信息，去对应的权威DNS服务器获取需要解析的地址的信息
+ 纯递归
  + 本地DNS服务器向根DNS服务器发送希望解析的地址
  + 根DNS服务器直接向对应的顶级域名服务器发送希望解析的地址
  + 顶级域名服务器向权威DNS服务器发送希望解析的地址
  + 权威DNS服务器向顶级域名返回结果，再一路返回回去

+ DNS缓存
  + 任何域名服务器一旦得知了某个映射，就将其缓存
  + 在一定的时间间隔后缓存的条目将会过期自动消除
  + TLD DNS服务器通常被缓存在本地DNS服务器中，这样可以减少根DNS的负载

+ DNS提供的服务
  + 域名到IP地址的转换
  + 主机/邮件服务器别名
    + 为不好记的规范主机/邮件服务器名提供一个容易记忆的别名
    + e.g. www.hotmail.com -> www.hotmail.aate.nsatc.net
  + 负载均衡
    + 一个域名对应多个IP
    + DNS服务器在多个IP中进行轮转

### 攻击DNS服务器
+ DDoS攻击
  + 通过ICMP Ping洪泛攻击根DNS服务器——难以成功
    + 根服务器通常配备分组过滤器
    + 大多数本地DNS服务器缓存了TLD DNS服务器的地址
  + 通过DNS请求报文洪泛攻击TLD DNS服务器
    + 难以过滤
+ 重定向攻击
  + 中间人攻击：攻击者截获来自主机的请求并返回伪造的回答
  + DNS毒害攻击：攻击者向一台DNS服务器发送伪造的回答，诱使服务器在它的缓存中接收伪造的记录
+ 利用DNS服务器对目标主机采用DDoS攻击：反射攻击

## P2P文件分发
+ 速度对比
  + C/S模式
    + $$ T_{CS} >= max \{ \frac{NF}{\mu _s}, \frac{F}{min\{d_1, d_2, ..., d_N\}} \} $$
  + P2P模式
    + $$ T_{P2P} >= max \{ \frac{F}{\mu _s}, \frac{F}{d_{min}}, \frac{NF}{\mu _s + \sum _1 ^N \mu _i} \} $$
+ 基本概念
  + BitTorrent的基本概念
    + 洪流torrent: 参与一个特定文件分发的所有对等方的集合
    + 追踪器tracker: 跟踪正参与在洪流中的对等方
    + 文件快chunk
  + BitTorrent的基本工作机制
    + 向邻居请求哪些块：最稀罕优先
    + 优先响应哪些请求：兑换算法（4+1）
      + 每10秒重新选则4个最高速率对等放
      + 每30秒随机选则一个新的邻居

# 运输层
## 概述和运输层服务
+ 运输层的功能
  + 为不同主机上运行的应用进程提供逻辑通信信道(logical communication)
+ 运输层协议的工作内容
  + 发送方：把应用数据划分为报文段(segments)，交付给网络层
  + 接收方：把报文段重组成应用数据，交付给应用层
+ 运输层和网络层的区别
  + 网络层：不同主机之间的逻辑通信
  + 运输层：应用进程之间的逻辑通信
  + 不同的运输层协议可能提供不一样的服务
  + 运输层协议能够提供的服务受到底层网络协议的服务模型限制
  + 在网络层不提供某些服务的情况下，运输层自己提供
+ 因特网上的运输层协议
  + 用户数据报协议UDP（数据报）
  + 传输控制协议TCP（报文段）
  + 提供的服务
    + 进程间的数据交付
    + 差错检测
    + 可靠的数据传输
    + 拥塞控制

## 多路复用与多路分解
+ 端口
  + 端口的作用就是让应用层各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程（或线程）
  + 端口是用来标志应用层的进程（或线程）
  + 端口用一个16bit端口号进行标志
+ 套接字
  + IP地址再互联网上唯一标识一台主机，端口号再一台主机唯一标识一个应用进程，将两者结合起来，可以在互联网上唯一的标识通信双方的一个断电，即应用进程，这两者的组合成为套接字。
+ 报文段（数据报）的投送
  + 主机收到IP包
    + 每个数据包都有源IP地址和目的IP地址
    + 每个数据包都携带一个传输层的数据报文段
    + 每个数据报文段都有源、目的端口号
  + 主机根据“IP地址+端口号”将报文段定向到相应的套接字

+ 面向连接的复用和分用
  + TCP套接字由一个四元组来标识(源IP地址，源端口号，目的IP地址，目的端口号)
  + 接收方主机根据这四个值将报文段定向到相应的套接字
  + 服务器主机同时支持多个并发的TCP套接字
  + Web服务器为每一个客户连接都产生不同的套接字
    + 非持久HTTP对每一个请求都建立不同的套接字

## 无连接传输：UDP
+ 最简单的运输层协议，必须提供
  + 多路复用/多路分解
  + 差错检查
+ UDP处理数据的流程
  + 发送方
    + 从应用进程得到数据
    + 附加上为多路复用/多路分解所需的源和目的端口号及差错检测信息，形成报文段（数据报）
    + 递交给网络层，尽力而为交付给接收主机
  + 接收方
    + 从网络层接收数据包
    + 根据目的端口号，将数据交付给相应的应用进程
  + UDP通信事先无需握手，是无连接的
+ UDP的优势
  + 无需建立连接：建立连接会增加时延
  + 简单：发送方和接收方无需维护连接状态
  + 段首部开销小：TCP: 20Bytes VS UDP: 8Bytes
  + 无拥塞控制：UDP可按需随时发送
+ 部分采用UDP协议的应用
  + 远程文件服务器(NFS)、因特网电话、域名解析、HTTP/3、网络管理(SNMP)、流式多媒体
+ UDP大量引用可能导致的严重后果
  + 路由器中大量的分组溢出
  + 显著减小TCP通信的速率，甚至挤垮TCP会话
+ 使用UDP的可靠数据传输
  + 在应用层实现数据的可靠传输
  + 增加了应用进程的实现难度
+ UDP报文段（数据报）的结构
  + 首部：源端口、目的端口、长度、检查和 & 应用数据（报文）
  + 其中，长度是包括首部在内的UDP报文段长度，以字节为单位
+ UDP的检查和
  + 目标：检测收到的报文段的“差错”
  + 发送方
    + 把报文段看作是16比特字的段序列
    + 检查和：对报文段的所有16比特字的和进行1的补运算
    + 发送方将计算校验和的结果写入UDP校验的字段中
  + 接收方
    + 计算接收到的报文段和检验和
    + 检查计算结果是否与收到报文段的校验和字段中的值相同
      + 不同-检测到错误
      + 相同-没有检测到错误，单仍然可能存在错误

## 可靠数据传输原理
+ 发送方：
  + `rdt_send()`：由上层（如应用层）调用，将数据发发送给接收方上层
  + `udt_send()`：由rdt调用，将分组通过不可靠通道传给接收方
  + `rdt_rcv()`：当分组到达接收方时调用
  + `deliver_data`由rdt调用，将数据交付给上层
### rdt1.0 
信道完全可靠，只要发送和接收数据就可以了
### rdt2.0
+ 信道可能导致比特出现差错时
  + 分组比特可能受损
  + 所有传输的分组都将按序被接收，不会丢失
+ 处理机制
  + 如何判断分组受损——差错检测
  + 如何通知发送方分组是否受损——接收方反馈(ACK&NAK)
  + 在得知分组受损后，发送方的处理手段——出错重传
  + 如何实现重传——使用缓冲区缓存已发送出但未收到反馈的报文——接收方和发送方各以ige报文段大小的缓冲区即可
  + ACK和NAK分组可能也受损——为分组添加编号——rdt2.1
### rdt2.2
+ 只使用ACK，没有NAK
+ 接收方对最后一个正确收到的分组发送ACK
+ 为便于接收方表明正确收到了哪一个分组，ACK中必须指出被确认分组的序号
+ 发送方收到重复的ACK按照NAK来处理
### rdt3.0
信道不但可能出错，还可能丢包
### rdt3.1
使用流水线技术提高传输的效率
+ 扩大分组序号范围——用k位进行序号编码
+ 扩大发送方乃至接收方的缓冲区大小——窗口
+ 当流水线技术中丢失一个分组后，如何进行重传
  + GBN协议：其后分组全部重传
  + SR协议：仅重传该分组
> 滑动窗口大小
> 发送端窗口+接收端窗口 $ <= 2^k $
#### GBN协议
+ 发送端 $ <= 2^k -1 $
+ ACK(N)：接收方对序号n之前包括n在内的所有分组进行确认——累积ACK
+ 对所有已发送但未确认的分组统一设置一个定时器
+ 超时(n)：重传分组n和窗口中所有序号大于n的分组
+ 失序分组
  + 丢弃（不缓存）->接收方无缓存
  + 重发按序到达的最高序号放分组的ACK 
> 发送方窗口 $ <= 2^k-1$
> 接收端=1
#### SR协议
+ 发送方：
  + 从上层收到数据
    + 如果下一个可用于该分组的序号在窗口内，则将数据打包并发送
  + 超时(n)
    + 重传分组n，重置定时器
  + 收到确认(n)在[sendbase, sendbase+N-1]分为内
    + 标记分组n为已接收
    + 如果n是发送窗口基序号sendbase，则将窗口基序号前推到下一个未确认序号
+ 接收方
  + 分组序号n在[rcvbase, rcvbase+N-1]范围内
    + 发送n的确认ACK(n)
    + 如果分组序号不连续（失序）：将其缓存
    + 按序分组：将该分组以及以前缓存的序号连续的分组一起交付给上层，将窗口前推到下一个未收到的分组
  + 分组序号n在[rcvbase-N, rcvbase-1]范围内
    + 虽然曾经确认过，仍再次发送n的确认ACK(n)
  + 其它情况：忽略该分组

在SR协议中，接收方窗口 $ <= 2^{k-1} $

| | GBN | SR |
|:--|:--|:---|
|确认方式|累计确认|单个确认|
|定时器|对所有已发送但未确认的分组统一设置一个定时器|对所有以发送但未确认的分组分别设置定时器|
|超时(n)|重传分组n和窗口中所有序号大于n的分组|仅重传分组n|
|失序分组|丢弃（不缓存）->接收方无缓存；重发按序到达的最高序号分组的ACK|缓存；对失序分组进行选择性确认|

## 面向连接的传输:TCP
+ 概述
  + 面向连接
  + 全双工服务
  + 点对点连接
  + 可靠有序的字节流
  + 流量控制 
  + 拥塞控制
  + 流水线

+ 关于序列号和ACK的进一步讨论
  + 序列号：在报文段数据中第一个字节在字节流中的编号
  + 确认ack
    + 期待得到的下一个字节的seq
    + 累计ack
    + Q:接收端如何处理乱序报文段实现
    + 答：TCP规范没有规定，由实现者实现

+ 样本RTT估算
  + 样本RTT：对报文段被发出到收到该报文的确认之间的时间进行测量（忽略重传）
  + 样本RTT会由波动，要使得估算RTT更平滑，需要将最近几次的测量进行平均（指数加权平均移动），而非仅仅采用最近一次的SampleRTT
    + $$ EstimatedRTT = (1-\alpha) * EstimatedRTT + \alpha * SampleRTT $$
    + 参考值$\alpha = 0.125$，第一次计算的时候，$EstimatedRTT = SampleRTT$
  + 考虑RTT的波动，估计EstimatedRTT与SampleRTT的偏差
    + $$ DevRTT = (1-\beta) * DevRTT + \beta * | SampleRTT - EstimatedRTT $$
    + 参考值$\beta = 0.25$，第一次计算时，$DevRTT=0.5*SampleRTT$
  + TCP中的超时间隔为 $TimeoutInterval = EstimatedRTT + 4 * DevRTT$

### 可靠的TCP数据传输
+ IP协议是不可靠的
+ TCP采用了rdt部分阐述的数据可靠传输方法
+ 特别之处：
  + TCP编号采用按字节编号，而非按报文段编号
  + TCP仅采用唯一的超时定时器

产生TCP ACK的建议
|接收方事件|TCP接收方动作|
|:---|:---|
|所期望序号的报文段按序到达。所有在期望序号及其以前的数据都已经被确认|延迟的ACK。对另一个按序报文段的到达最多等待500ms.如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK|
|由期望序号的报文段按序到达。另一个按序报文段等待发送ACK|立即发送单个累计ACK，以确认两个按序报文段|
|比期望序号大的失序报文段到达，检测出数据流中的间隔|立即发送冗余ACK，指明下一个期待字节的序号（也就是间隔的低端字节序号）|
|能部分或完全填补接收数据间隔的报文段到达|倘若该报文段起始于间隔的低端，则立刻发送ACK|

#### 快速重传
+ 超时周期往往太长
  + 增加重发丢失分组的延时
+ 通过重复的ACK检测丢失报文段
  + 发送方常要连续发送大量报文段
  + 如果一个报文段丢失，会引起很多连续的重复ACK
+ 如果发送收到一个数据的3个重复ACK，他会认为确认数据之后的报文段丢失
+ **快速重传**：在超时到来之前重传报文段


#### 超时间隔加倍
+ 每一次TCP重传均将下一次超时间隔设为先前值的两倍
+ 超时间隔由EstimatedRTT和DevRTT决定
  + 收到上层应用的数据
  + 收到未确认数据的ACK

#### TCP流量控制
+ 背景
  + TCP接收方有一个缓存，所有上交的数据全部缓存在里面
  + 应用进程从缓冲区中读取数据可能很慢
+ 目标
  + 发送方不会由于传得太多太快而使得接收方缓存溢出
+ 手段
  + 接收方在反馈时，将缓冲区剩余空间的大小填充在报文段首部的窗口字段中，通知发送方
+ 计算
  + 接收方：
    + LastByteRcvd - LastByteRead <= RcvBuffer
    + RcvWindows = RcvBuffer - [LastByteRcvd - LastByteRead]
  + 发送方
    + LastByteSent - LastByteAcked <= RcvWindow
+ 特殊情况
  + 接收方通知发送方RcvWindow为0，且接收方无任何数据传送给发送方
  + 发送方持续向接收方发送只有一个字节数据的报文段，目的是试探

#### TCP连接的建立与释放
| 主机A | 主机B|
|:--|:--|
|连接请求 SYN, SEQ=x| |
| | 确认 SYN, ACK, SEQ=y, ACK=x+1|
|确认 ACK, SEQ=x+1, ACK=y+1|

| 主机A | 主机B|
|:--|:--|
|应用进程释放连接，A不再发送报文 FIN, SEQ=x| 通知主机应用进程|
| | 确认 ACK, SEQ=y, ACK=x+1|
|此时A不会再向B发送数据，但是仍然能够接收B发送的数据，处于半关闭状态||
| |应用进程释放连接，B不再发送报文 FIN, ACK, SEQ=y, ACK=x+1|
|确认 ACK, SEQ=x+1, ACK=y+1| | 

|客户机状态|客户机动作|服务器状态|服务器动作|
|:---|:---|:--|:--|
|CLOSED||CLOSED -> LISTEN|服务器应用程序创建一个监听套接字|
|CLOSED -> SYN_SENT|客户端应用程序启动一个TCP连接，发送SYN|LISTEN -> SYN_RCVD|接收SYN并发送*SYN&ACK*|
|SYN_SENT -> ESTABLISHED|接收*SYN&ACK*，并发送ACK|SYN_RCVD -> ESTABLISHED|接收ACK，不发送|
|ESTABLISHED -> FIN_WAIT1|客户端应用程序启动关闭连接|ESTABLISHED -> CLOSE_WAIT| 接收FIN,发送ACK|
|FIN_WAIT1 -> FIN_WAIT2|接收ACK，不发送|CLOSE_WAIT -> LAST_ACK| 发送FIN|
|FIN_WAIT2 -> TIME_WAIT|接收FIN,发送ACK|LAST_ACK -> CLOSED|接收ACK，不发送|
|TIME_WAIT -> CLOSED|时间到了变为CLOSED状态| | |

### 拥塞控制
#### 拥塞控制原理
+ 非正式定义：“过多的源发送了过多的数据，超出了网络的处理能力”
+ 现象
  + 丢包（路由器缓冲区溢出）
  + 延时长（在路由器缓冲区排列）
    + 不同于流量控制！
+ 拥塞控制的方法
  + 网络辅助的拥塞控制
    + 直接网络反馈：路由器以阻塞分组的形式通知发送方“网络拥塞了”
    + 经由接收方的网络反馈：路由器标识从发送方刘翔接收方分组终端某个字段以只是拥塞的产生，由接收方通知发送方“网络拥塞了”
  + 端到端拥塞控制
    + 网络层不为拥塞控制提供任何帮助和支持
    + 端系统通过对网络行为（丢包或时延增加）的观测判断网络是否发生拥塞

#### TCP拥塞控制
+ 传统TCP拥塞控制为端到端拥塞控制
  + 每个发送方自动感知网络拥塞的程度
  + 发送方根据感知的结果限制外发的流量
    + 如果前方路径上出现了拥塞，则降低发送速率
    + 如果前方路径上没有出现拥塞，则增加发送速率
+ 传统的TCP拥塞控制需要解决的三个问题
  + TCP发送方如何限制外发流量的速率
    + 拥塞窗口
      + $LastByteSent - LastByteAcked <= CongWin \quad rate = \frac{CongWin}{RTT} Bytes/sec$
    + 发送方如何感知拥塞
      + 超时
      + 三个冗余ACK
    + 在感知到拥塞后，发送方如何调节发送速率

##### Reno算法
+ 加性增，乘性减(AIMD)
  + 当出现丢包事件后将当前CongWin大小减半，可以大大减少注入到网络中的分组数
  + 当没有丢包事件发生了，每个RTT之后将CongWEin增大1个MSS，使拥塞串口缓慢增大，防止网络过早出现拥塞
+ 慢启动
  + 建立连接时，CongWin=1MSS
  + 可用带宽>>MSS/RTT
    + 初始阶段以指数的速度增加发送速率
  + 连接初始阶段，以指数的速度增加发送速率，直到发生一个丢包事件为止
    + 每收到一次确认则将CongWin的值增加一个MSS
  + 总结：初始速率很低，但速率的增长速度很快
+ 对收到3个重复ACK的反应——快速重传
  + 门限值设为当前CongWin的一半（门限值初始值65KB）
  + 将CongWin减为新的门限值+3MSS
  + 线性增大拥塞窗口
+ 对超时事件的反应
  + 门限值设为当前CongWin的一半（门限值初始值65KB）
  + 将CongWin设为1个MSS大小
  + 窗口以指数速度增大
  + 窗口增大到门限值之后，再以线性速度增大
+ 快速恢复（TCP推荐但非必须实现）
  + 3个冗余ACK进入快速重传后
  + 每收到一个冗余ACK: CongWin++
  + 直至收到一个新的ACK: CongWin=门限值，重新进入拥塞避免
  + 在进入快速恢复之后及重新进入拥塞避免之间，如果出现超时现象，直接按照前述超时事件进行处理
+ 总结
  + 当拥塞窗口CongWin小于门限值Threshold时，发送方处于慢启动阶段，窗口以指数速度增大
  + 当拥塞窗口CongWin大于门限值Threshold时，发送方处于拥塞避免阶段 ，窗口线性增大
  + 当收到3个重复的ACK时，门限值Threshold设为拥塞窗口的1/2，而拥塞窗口CongWin设为门限制值Threshold+3个MSS
  + 当超时事件发生时，门限值Threshold设为拥塞窗口的1/2，而拥塞窗口CongWin设为1个MSS
+ Reno算法的改进——new reno
  + reno存在的问题：当收到一个新的ACK，就会执行快速恢复，CongWin收缩到门限值，可能导致较长时间内无法发送新的报文段，也无法触发快速重传的机制
    + 信道空闲
    + timeout直接回到慢启动
  + 解决方案
    + 记录进入快速重传时的已发送的最高报文序号Recovery
    + 每收到一个新的ACK，如果序号不大于Recovery，不退出快速恢复，而是重传该ACK后的报文段
    + 一旦ACK序号大于Recovery，立即退出快速恢复，收缩到门限值
  + 新的问题
    + 部分分组可能已经被接收，无意义的重发
  + 解决方案
    + 在TCP报文段的选项字段中，增加SACK，选则重传
+ TCP Reno的吞吐量
  + 在忽略慢启动的情况下
  + 当发生丢包事件前，窗口大小为W，吞吐量为$\frac{W}{RTT}$
  + 丢包事件发生后，窗口大小减为$\frac{W}{2}$, 吞吐量为$\frac{W}{2RTT}$
  + 平均吞吐量$0.75\frac{W}{RTT}$
+ Reno算法吞吐量的一个问题
  + 将拥塞窗口值减半甚至减到1MSS，无法充分的利用链路带宽
  + CUBIC方案
    + 不调整慢启动和快速恢复，仅优化拥塞避免阶段
    + $W_{max}$: 最后检测到丢包时TCP拥塞窗口的大小
    + K: 无丢包情况下，拥塞窗口再次达到$W_{max}$的未来时间点
    + 拥塞窗口增加量=$f(|t-K|^3)$
##### Vegas算法
+ Reno和CUBIC会稳定提高TCP发送速率，直到某个路由器的输出端出现数据包丢失为止：瓶颈链路
+ 关注瓶颈链路对于了解拥塞状况是有价值的
+ 提高TCP发送速率并不会增加存在拥塞瓶颈的端到端吞吐量
+ 提高TCP发送速率会增加测得的RTT
+ 目标：保持管道刚好充满，而不可以更满：让瓶颈链路忙于传输，但避免高延迟/缓冲
+ 基于时延的方法
  + $RTT_{min} - 观察到的最小的RTT(无拥塞状态)$
  + 无拥塞著阳台的吞吐率=$\frac{cwnd}{RTT_{min}}$
  + 测量得到的吞吐率=$\frac{上一个RTT周期内发送的字节数}{RTT_{测量}}$
```
if 测得吞吐率“非常接近”无拥塞状态的吞吐率
  线性增加cwnd  /* 因为路径上无拥塞 */
else if 测得吞吐率“远小于”无拥塞状态的吞吐率
  线性减小cwnd /* 因为路径上有拥塞 */
``` 
+ 拥塞控制过程中不存在诱导/强制性能损失
+ 在保持低时延的同时，最大化吞吐率

#### 明确拥塞通告
+ TCP部署通常会实施网络辅助拥塞控制
  + 路由器在IP头(ToS字段)中标记的两个比特，用于指示拥塞情况
    + 由网络的运营商选则确定标记的策略
  + 拥塞指示由IP数据报携带送达目标主机
  + 目标主机设置ACK报文段的ECE比特通知源主机：网络中存在拥塞
  + 源主机调整拥塞窗口大小后（通常是减半），设置下一个报文段的CWR比特通知目标主机：拥塞窗口大小已减小

#### TCP拥塞控制的公平性分析
+ 公平性的目标
  + 如果K个TCP连接共享同一个带宽为R的瓶颈链路，每个连接的平均传输速率为R/K
+ 公平性和UDP
  + 多媒体应用一般不使用TCP
    + 不希望因为拥塞控制影响其速率
  + 多媒体应用采用UDP
    + 恒定的速率传输音频和视频数据，可容忍丢包
+ 公平性和并性TCP连接
  + 无法组织应用在两个主机之间建立多个并性的连接(Web浏览器就是这样)

## 运输层功能的演化

# 网络层
## 网络层概述
+ 网络层在计算机网络中的地位
  + 为运输层提供支持
    + 运输层实现进程到进程的通信
    + 运输层功能的实现依赖于网络层提供的服务
  + 为实现从源主机到目标主机成功地转发数据分组，端到端路径上的每台分组交换机上均需实现网络层
+ 网络层的目标
  + 实现主机到主机的通信
    + 如何选路
    + 如何转发
    + 确定是否可达

### 网络层的主要功能
+ 选路
  + 在全局范畴为主机之间的通信进行选路，选路的结果反应为分组交换机上的转发表
+ 转发
  + 分组交换机上的网络层根据转发表以及分组首部信息，将分组通过对应链路进行转发
+ 状态报告
  + 通过控制消息感知网络通不通、主机是否可到达、路由是否可用等状态
+ 连接建立
  + 对于面向连接的完了过曾服务，提供连接建立的功能
+ 可能提供的服务
  + 确保交付
  + 具有时延上界的确保交付
  + 有序分组交付
  + 确保最小带宽
  + 确保最大时延抖动

几种实际使用的网络层服务模型
|网络体系结构|服务模型|带宽保证|无丢失保证|排序|定时|拥塞指示|
|:----------|:------|:------|:---------|:--|:---|:------|
|因特网|尽力而为|无|无|无|不维持|无|
|ATM|CBR|保证恒定速率|是|有序|维持|无拥塞|
|ATM|ABR|保证最小速率|无|有序|维持|提供指示|

## 虚电路和数据报网络
+ 网络层选路转发服务
  + 虚电路服务：面向连接的服务，需事先握手
  + 数据报服务：面向无连接的服务，无需握手

#### 虚电路服务
+ 虚电路服务
  + 收发双方之间的路径如同电话线路一般
  + 数据传输前，呼叫建立；传输结束后断开连接
  + 每一个分组携带许电路的标识（而不是目的主机的地址）
  + 路径上的每个路由器必须为进行中的连接维持连接状态信息
  + 链路，路由器资源（带宽、缓冲区）可以分配给虚电路
+ 虚电路的组成
  + 从源到目的主机的路径
  + VC号，沿着该路径的每段链路的一个号码
  + 沿着该路径的每台路由器中的转发表

#### 数据报服务
+ 数据报服务
  + 在网络层没有连接建立的过程
  + 不维护连接状态信息
  + 同一对主机间的报文可能会走不同的路径

##### 虚电路和数据报比较
|虚电路网络|数据报网络|
|:--|:--|
|聪明的网络，愚笨的终端|简单的网络，复杂的终端|
|保证速率和服务质量|互联不同类型的网络更加容易|
|定时维持状态|启用新服务的速度更快，更简单|

#### 网络层与运输层相应服务的区别
|网络层|运输层|
|:---|:--|
|向运输层提供主机到主机的服务|向应用层提供进程到进程的服务|
|仅提供面向连接或面向无连接两种服务中的一种|同时提供两种|
|网络层的服务则在整个网络中实现，含路由器|运输层的五福在网络边缘的端系统中实现|

## 路由器的工作原理
+ 数据包排队
+ 交换单元：输入输出匹配
+ 每次1个数据包从输入端口转交给输出端口，若要转交到相同输出端口，则一个通，其它阻塞
### 路由器输入端口
+ 物理层 --> 线路端接口
+ 数据链路层 --> 数据链路处理（协议、拆封）
+ 分散式交换 --> 网络层处理（排队、查表、转发...）
  + 根据目的地址，输入端口内存中的路由选择表，查找确定输出端口
  + 目标：以“线路速度”完成输入端口的处理
  + 排队：若数据报到达速度超过端口到交换结构的转交速度，后续分组会暂时阻塞
    + 输出端口竞争时候会要排队
    + 线头阻塞：输入队列中排队分组被位于线头的另一个分组阻塞，须等待交换结构发送
    + 输入缓冲区溢出可导致排队时延和丢包

### 路由器交换结构
+ 内存交换
  + 输入和输出端口间的交换是在路由器的直接控制下完成
  + 分组被拷贝到系统内存中，在CPU的控制下转发至输出端口
  + 转发速度受限于内存带宽（每个分组走两次总线）
+ 总线交换
  + 输入报文经共享总线将分组直接转发到输出端口
  + 总线交换速度受限于总线带宽
+ 内联网络
  + 客服总线带宽限制
  + Banyan网络：用于计算机体系结构中多处理机互联
  + 固定分组转发：将长度变化的IP分组拆分为固定尺寸的单元，通过交换网络进行转发

### 输出端口
+ 缓存管理：当交换结构转交给输出端口的速率超过输出链路速率时
+ 调度原则：在数据报队列中选则数据报进行传输
+ 输出端口排队
  + 当通过交换结构到达的分组速率超过了输出链路的速率时，需要对分组进行缓存
  + 输出端口缓冲区溢出会导致分组的排队和丢失
+ 缓存及排队策略
  + 对于有N条TCP链接经过的链路而言
  + $$ B = \frac{RTT \times R}{\sqrt{N}} $$
  + 调度策略
    + 先来先服务FCFS
    + 加权公平排队WFQ

### 缓存及排队策略
+ 分组排队丢弃策略
  + 被动队列管理
    + 弃尾策略
    + 删除一个或者多个已排队分组
  + 主动队列管理——随机早期检测RED
    + 随时计算平均队列长度$avg_{th}$
    + 最小阈值$min_{th}$, 最大阈值$max_{th}$
    + $avg_{th}$小于$min_{th}$, 允许分组入列
    + $avg_{th}$大于$max_{th}$, 分组被标记或丢弃
    + $avg_{th}$在$min_{th}$和$max_{th}$之间，按照概率标记或丢弃分组

##### 路由表的内容
| 目的网络地址 | 子网掩码 | 下一跳 |
|:--|:--|:--|
|网络号的那个地址|~|既可以是接口，也可以是路由器|

## IP数据报格式
+ 版本
  + 4bit，如IPv4,IPv6，版本协议不同，无法通信
+ 服务类型
  + 8bit，用于服务质量保证
  + 报文处理方式，每一位分别代表最小延时、最大吞吐量、最高可靠性、最小成本，只选一个
  + 最新的服务类型6位定义区分服务，2位保留
+ 生存时间
  + 分组寿命管理，避免数据报进入循环路由无法退出
  + 反映源目的主机之间数据报经历的跳数，每经过1个节点，跳数减1
  + 不同系统，TTL默认最大取值不同
+ 首部检验和
  + 16bit，差错检测，只检验首部
+ 协议
  + 8bit，用于标识传输层地址或协议
+ 源地址: 32bit
  + 发送端标识，IP地址
+ 目的地址: 32bit
  + 接收端标识，IP地址
+ 报文长度相关字段
  + 首部长度: 4bit, 单位4字节，取值范围5-15，即20-40字节
  + 总长度: 16bit, 单位是字节，取值范围0-65535，实际报文数据长度位总长度减去首部长度。以太网链路报文只允许1500字节
+ 分片相关字段
  + 标识: 16bit, 网络层服务的上层传输层的同义词报文（可能超过1500字），使用相同的标记，相当于每次会话使用相同标识
  + 标志: 3bit，第1位保留；第2位表示是否能分片；第3位标识分片是否结束：1为未结束，0为结束
  + 片偏移：每个分片在整个报文（分组）中的位置（8字节为度量单位）
+ 链路层帧大小有限，超过如何处理
  + 网络链路MTU（最大传输单位）有限
    + 不同类型的链路有不同的MTU值
  + IP数据报需分片和重组
    + 将一个打数据报拆分为几个小数据报
    + 重组只在目的主机进行
    + 数据报首部的标识、标志以及片偏移三个字段用于分片和重组

## IP地址
+ IP地址与接口有关，而与主机，路由器却没有太多关联
+ IP地址使用于主机、路由器内部和它们之间的物理链路和逻辑链路接口
+ IP地址是网络号+主机号形成的

|类型| | | | |适用|
|:--|:--|:--|:--|:--|:--|
|A类|0|网络号|主机号|大型网络|
|B类|10|网络号|主机号|中型网络|
|C类|110|网络号|主机号|小型网络|
|D类|1110|组播地址| | |
|E类|1111|保留为今后使用| | |

+ 互联网中的IP地址
  + 在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的。
  + 路由器总是具有两个或以上的IP地址。路由器的每一个接口都有一个不同网络号的IP地址
+ IPv4面临的问题
  + 地址空间消耗很快
    + 通过NAT减少了IP地址的需求量，间接扩大了IP地址的数量
  + 首部长度不定（20-60字节），中间节点（路由器）需要消耗相当资源用于分组处理
  + 缺少QoS
  + 安全性不够高

#### IPv6数据报格式
+ 格式
  + 版本: 4bit
  + 流量类型: 8bit
  + 流标签: 20bit
  + 有效载荷长度: 16bit
  + 下一个首部: 8bit
  + 跳限制: 8bit
  + 源地址: 128bit
  + 目的地址: 128bit
  + 数据
+ 无检查和，中间节点无需计算
+ 中间节点不再负责分片和重组，由端节点负责
+ 首部长度固定，加速中间节点转发速度

#### IPv4到IPv6的迁移
+ 双栈技术
  + 新加入的设备支持IPv4/IPv6双协议栈
  + 一段链路上，如果源和目标均支持IPv6，则使用IPv6进行通信
  + 如果任一方不支持IPv6，则使用IPv4进行通信
  + 可能会出现信息的丢失
+ 隧道技术

## 子网划分
#### 子网掩码
将两级IP(网络号+主机号)的主机号部分，分靠前部分的几位出来作为子网号，变成三级IP(网络号+子网号+主机号)

子网掩码：将网络号和子网号相应的位置全置1，主机号相应位置全置0，即可得到子网掩码

划分子网时的网络地址就成为了
$$ IP \& 子网掩码 = 网络地址 $$

#### 子网掩码的作用
+ 对外隐藏子网的存在，对内指示网络号和子网络号的位置

#### 子网寻址
+ 引入子网掩码后，路由器的寻址过程将演变成一个两级寻址过程
  + 检查目的IP地址的网络号
  + 检查目的IP地址的子网号

## 无类域间路由CIDR
+ CIDR编址格式
  + IP地址 ::= {<网络前缀>, <主机号>}
  + 斜线记法: 192.168.0.1/24
  + 简写记法: 10.0.0.0/10 -> 10/10
+ CIDR寻址
  + 最长前缀匹配
    + 使用CIDR时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果
    + 应当从匹配结果中选则具有最长网络前缀的路由：最长前缀匹配
    + 网络前缀越长，其地址块就越小，因而路由就越具体
    + 最长前缀匹配又成为最长匹配或最佳匹配
  + CIDR路由匹配可能存在多个结果，这种时候就要选则最长前缀的地址

#### DHCP协议
+ DHCP协议并不仅仅只能获取IP地址
  + 网关地址
  + DNS地址
  + 子网掩码

## 网络地址转换NAT
+ 为什么需要网络地址转换NAT
  + 外网获取的IP地址资源有限
  + 内网IP地址变动无需告知外网
  + 更换ISP后内网IP地址不变
  + 内网主机外网资源不可见
+ NAT的意义
  + 本地网络只要使用一个IP地址就可以和外部网络相连
  + 不需要从ISP出获得大批IP地址：所有设备可以使用同一个IP地址
  + 可以在不通知外部网络的情况下改变内网主机的IP地址
  + 即使改变了ISP也无须改变内网主机的IP地址
  + 内网主机对外网主机而言是不可见的、不可寻址的
+ NAT的实现
  + 发送数据报：将每个外出报文的源IP地址，端口号替换为NAT  IP地址以及新的端口号
    + 远程客户机/服务器将以NAT IP地址以及新的端口号作为目的地址进行相应
  + 记住每一个地址转换对（在NAT转发表中），即(源IP地址, 端口号) -> (NAT IP地址, 新的端口)
  + 接收数据报：根据NAT转换表将每个进入报文的NAT IP地址，端口号替换为相应的源IP地址以及端口号
+ NAT中的本地地址：
  + 10/8
  + 172.16/12
  + 192.168/16
+ 三种地址转换方式
  + 静态NAT：一个本地地址对应一个全球地址
  + 动态NAT：一个全球地址对应多个本地地址
  + 端口NAT：一个本地地址的端口对应到一个全球地址的端口
+ NAT内网访问方案
  + 端口映射：采用端口NAT，在路由器中静态的为服务器配置一条记录
  + 通用即插即用UPnP(用于P2P)
    + 内部主机通过IGD协议了解公共IP地址
      + 向路由器注册/移除映射记录 (内部IP, 内部端口) -> (公共IP, 公共端口)
    + 内部主机向外部公开(公共IP， 公共端口)
  + 中继(用于Skype)
+ NAT带来的争议
  + 端口号应该用于进程编址，而飞用于主机编址
  + 路由器仅应当处理高达第三层的分组
  + NAT协议违反了端到端原则，中间节点不应介入
  + 应使用IPv6来解决IP短缺的问题

## ICMP协议
+ 为什么需要ICMP
  + IP数据报逐段转发
  + IP数据报非可靠传输
  + 网络状态不可知
+ ICMP的作用
  + 错误报告
  + 请求/应答
  + 报文控制

#### ICMP协议报文分类
+ 差错于控制报文协议ICMP
  + 差错报告报文
    + 信息不可到达报告
    + 超时报告
    + 参数出错报告
  + 控制报文
    + 源抑制报文
    + 重定向报文
  + 请求/应答报文
    + 回应请求/应答报文
    + 时间戳请求/应答报文
    + 地址模请求/应答报文

#### ICMP报文格式
前4个字节统一都是类型(1字节)代码(1字节)检验和(2字节)

ICMP报文封装在IP组中

ICMP消息：一个类型字段和一个编码字段

|类型|代码|描述|
|:--|:--|:--|
|0|0|回声回答（对ping的回答）|
|3|1|目的主机不可达|
|3|2|目的协议不可达|
|3|3|目的端口不可达|
|3|6|目的网络未知|
|3|7|目的主机未知|
|4|0|源抑制（拥塞控制，未用）|
|8|0|回声请求（ping）|
|9|0|路由器通告|
|10|0|路由器发现|
|11|0|TTL过期|
12|0|IP首部错误|

##### 信息报文不可达
+ 信宿机硬件出现故障或关机
+ 发送者指定的地址不存在
+ 网关不知道去往信宿的路径

|类型(3)|码(0-12)|校验和|
|:---|:---|:---|
|未用(全0)|
|出错数据报报头+前64bit数据|
|...|

##### 参数出错报文
+ 路由器或信宿机在丢弃参数出错的报文时
|类型(12)|码(0或1)|校验和|
|:--|:--|:--|
|指针|未用(全0)|
|出错数据报报头+前64bit数据|
|...|

+ 0：数据报某个参数错，指针域指向出错字节
+ 1：数据报缺少某个选项，无指针域

##### 重定向报文
+ 路由转发过程中发现源主机可以将报文直接发送给下游路由节点

|类型(5)|码(0-3)|校验和|
|网关IP地址|
|数据报包头+前64bit数据|
|?...|

+ 1：对主机重定向报文
+ 2：对服务类型和网络的重定向报文
+ 3：对服务类型和主机的重定向报文

ICMP差错报告与控制报文是单项传输的报文

#### ICMP协议的应用
+ ping：使用ICMP回送和应答消息来确定一台主机是否可达
+ tracert：确定到目的地主机的确切路由器

## 选路算法
+ 概念
  + 默认路由器：一台主机“直接”连接到的路由器
  + 源路由器：源主机的默认路由器
  + 目的路由器：目标主机的默认路由器
+ 选路算法的目的：给定一组路由器以及连接路由器的链路，从中找到一条从源路由器到目标路由器的“好的”的路径
  + “好的”通常指具有最低费用的路径 
+ 选路算法分类
  + 根据信息是全局性还是分散式的进行分类
    + 全局选路算法
      + 所有路由器都直到整个网络拓扑图以及链路的费用信息
      + 链路状态算法
    + 分散式选路算法
      + 每个路由器仅有与其相连链路的费用信息
      + 通过迭代计算过程与相邻节点交换信息
      + 距离向量算法
  + 根据信息是静态还是动态的进行分类
    + 静态选路算法
      + 随着时间的流逝，路由的变化非常缓慢
    + 动态选路算法
      + 路由信息可以更快的发生变化
      + 周期性的更新
      + 可以相依你个拓扑或链路费用的变化
  + 根据是否对负载敏感进行分类
    + 负载敏感算法
      + 链路费用会动态地变化以反应出链路当前的状况
    + 负载迟钝算法
      + 链路费用不明显地反应链路当前状况

### 链路状态选路算法
#### Dijkstra's算法
+ 所有节点都直到网络拓扑和链路费用
  + 通过链路状态广播获得信息
  + 所有节点具有该网络的同一个完整的视图
+ 计算从某节点到网络中所有其它节点的最低费用
  + 为该节点提供转发表
+ 迭代：经过算法的K次迭代后，可直到到K个目的节点的最低费用路径
+ 符号定义
  + `c(x, y)`：从节点x到节点y的链路费用；如果x和y不是直连的，则$c(x, y) = \infty$
  + `D(v)`：随着算法进行本次迭代，从源节点到目的v的最低费用路径的费用
  + `p(v)`：从源节点到v沿着当前最低费用路径的前以节点
  + `N'`：节点子集。v在`N'`中，如果从源节点到路径的最低费用路径已知
```
Initialization:
N' = {u}
for all nodes in v
  if v adjacent to u
    then D(v) = c(u, v)
  else D(v) = inf

Loop
  find w not in N' such that D(w) is a minimum
    add w to N'
    update D(v) for all v adjacent to w and not in N'
      D(v) = min( D(v), D(w) + c(w, v) )
until all nodes in N'
```
+ 算法复杂性
  + 对于第一次迭代：需要搜索所有的n个节点以确定出节点w，w不在N'中切具有最低费用
  + 在所有迭代中需要搜索的节点总数为$\frac{n(n+1)}{2}$，所以链路状态算法在最差情况下复杂性为$O(n^2)$
  + 该算法的一种更复杂的实现，使用了堆，其计算复杂性为$O(m log n)$
+ 存在的问题
  + 虽然算法本身没有问题，但是如果完全纯粹依赖dijkstra，可能导致有的链路负载过大，有的链路又空闲
  + 解决方案
    + 强制链路费用不依赖于所承载的流量
      + 无法解决高拥塞的问题，不可不可接受
    + 确保所有的路由器不同时运行LS算法
      + 因特网上的路由器能够自同步
      + 随机化路由器发送链路通告的时间

#### 因特网中的链路状态选路——OSPF协议
+ 协议交互范围及方法
  + OSPF协议消息限于本自治系统域内
  + OSPF协议消息采用泛洪发送
+ 协议交互信息内容
  + 与本路由器相邻的所有路由器的链路状态
+ 协议交互时机
  + 仅当链路状态发生变化时，采用泛洪法向所有路由器发送信息

+ OSPF路由协议相关链路状态数据库
  + 路由器之间频繁的交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库
  + 链路状态数据库实际上就是全网拓扑结构图，它在全网范围内是一致的
  + OSPF的链路有状态数据库能较快的进行更新，使各个路由器能及时更新其路由表。OSPF的更新过程收敛得快是其重要优点
+ OSPF如何保证所有节点知道网络拓扑和链路费用？
  + 洪泛法：本路由向本AS中所有路由器发送信息
  + 消息内容：与本路由器相邻的所有路由器的链路状态
  + 发送时机：当链路状态发生变化时开始发送
+ 链路状态数据库的优缺点
  + 所有路由器上均有全网一致的拓扑结构图
  + 更新过程收敛较快
  + 但是数据库存储空间占用很大
  + 最小生成树耗时大
  + 拓扑变化导致网络动荡

+ OSPF的补充说明
  + 不强制如何设置链路有权值的策略，但提供对给定链路权值集合确定最低费用路径的机制
  + 即使链路状态未发生变化，每30分钟广播一次链路状态
  + 链路状态以OSPF通告的形式封装在包尔维尼中，由IP分组承担（协议号：89）
  + OSPF路由器之间的交换都是经过鉴别的（简单的、MD5的），以确认OSPF通告的真实性，防止伪造和篡改
  + OSPF通告都是有序列号的，以防止重放攻击
  + OSPF中支持多条具有相同费用的路径
  + OSPF支持多播选路和层次路由

### 距离向量选路算法
距离向量的计算
$$ d_x(y) = min_v \{c(x, v) + d_v(y) \} $$
x到y的最短距离，等于在所有与x相邻的点的距离，分别加上这些相邻点到y点的距离 （就是一个递归）

+ RIP路由表更新算法
  + 路由器X得到相邻路由器Y的路由表，从而得知：Y到网络Z的最短距离为N
  + 如果路由器X没有到网络Z的路由条目，则添加一条经由路由器Y到网络Z距离N+1的路由条目
  + 如果路由器X已有到网络Z的路由条目，其距离为M，如果$M > N+1$，则更新该条目为经由路由器Y到网络Z并且距离为N+1，否则不更新
+ 链路状态改变时的特点
  + 好消息传得快
  + 坏消息传得慢
    + 无穷计数
    + 路由环路
+ RIP协议重要参数
  + 链路费用：相邻两点链路费用为1“跳”，最大费用限制为15
  + 通告周期：选路更新通告周期为30秒
  + 邻居离线：邻居离线判定周期为180秒
  + 协议端口：基于UDP，端口为520

### LS VS DV
| | LS | DV |
|:--|:--|:--|
|报文数量|n个节点，E条链路$O(nE)$|只在直连的邻居之间交换报文取决于邻居数|
|收敛速度|$O(n^2)$，可能震荡|路由环路，无穷计数|
|健壮性|节点能够向其连接的链路，广播不正确费用，独立计算路由表|一个节点可向任意或所有目的节点通告其不正确的最低费用路径。每个节点的计算都会传递给它的邻居，错误被传播|

## BGP-4协议
+ 层次路由
  + 因特网规模过大
    + 路由器无法存储每台主机的选路信息
    + 路由表更新的报文广播将导致无剩余带宽发送数据使用
  + 管理自治
    + 因特网=网络的网络
    + 每个网络管理员可能希望能够按自己的愿望运行和管理其网络
  + 解决方案
    + 将路由器聚合到一个区域，“自治系统”(AS)
    + 在相同AS内的路由器可全部运行同样的选路算法
  + 自治系统内部选路协议
    + 内部网关协议IGP(Interior Gateway Protocal)，目前这类路由选则协议使用的最多，如RIP和OSPF
  + 在不同AS内的路由器可以运行不同的自治系统内部选路协议

#### 层次路由——转发选路算法
+ 转发表是由AS内部选路算法和AS间选路算法共同决定的
  + AS内部选路算法为内部目的地址设置转发表信息
  + AS内部选路算法和AS间选路算法共同为外部目的地址设置转发表信息
+ 自治系统间路由器的任务
  + 当从源到目标有多条选路可走时，转发表必须能够确定路径
  + 热土豆选路：选则具有最小最低费用的网关
+ 层次路由——层次OSPF
  + 为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域
  + 每一个区域都有一个32bit的区域标识符
  + 区域也不能太大，在一个区域内的路由器最好不要超过200个
  + 划分区域
    + 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量
    + 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其它区域的网络拓扑的情况
    + OSPF使用层次结构的区域划分。在上层的区域叫做主干区域(backbone area)。主干区域的标识符规定为0.0.0.0.主干区域的作用是用来连同其它在下层的区域。

### 因特网上的AS间路由——BGP4
+ 因特网的规模太大，使得自治系统之间路由选则非常困难
  + 对于自治系统之间的路由选则，要寻找最佳路由是很不现实的
  + 自治系统之间的路由选则必须考虑技术无关的一些策略
+ BGP为每个AS提供一种手段，以处理
  + 从相邻AS获取子网可达性信息
  + 向该AS内部的所有路由器传播这些可达性信息
  + 基于该可达性信息和AS策略，决定到达子网的“好”路由
    + 边界网关协议BGP只能是力求寻找一条能够 到达目的网络切比较好的路由（不能兜圈子），而非寻找一条最佳路由
+ BPG-4与BGP发言人
  + 每一个AS要选则一个路由器作为该AS的“BGP发言人”
  + 两个BGP发言人通过一个共享网络连接在一起的
+ BPG路由通告
  + 当一个路由器得知一个新前缀，它为该前缀在其转发表中创建一个表项
  + BPG消息中会包含“路由”
    + “路由”包括前缀和属性：AS-PATH, NETX-HOP
+ BPG路由选则
  + 当有两条或者更多条最佳域间路由
  + 采用热土豆思想选则距离NEXT-HOP最近的路由
    + 采用IGP确定哪个边界路由器是最近的
  + 获取NEXT-HOP属性
  + 获取最短路径
  + 确定端口，加入转发表

## 路由协议总结
| | RIP | OSPF | BGP |
|:--|:--|:--|:--|
|协议类型|IGP|IGP|EGP|
|信息表达格式|距离-向量协议|链路-状态协议|路径向量|
|交换信息范围|相邻路由器|自治系统或区域内路由器|BGP发言人|
|交换信息内容|路由表|链路状态|路径向量|
|交换信息时间|每30秒|当链路状态变化|有变化|
|原则|最短路径|最小代价|可达性|
|收敛过程|较快|快|快|
|传输协议|UDP|IP|TCP|
|适用网络类型|小型网络|大型网络|自治系统之间|
|衡量标准|距离|可有多种度量标准|无|

# 链路层和局域网
## 链路层概述
+ 术语
  + 节点：主机和路由器
  + 链路：沿着通信路径连接相邻节点的通信信道
    + 有线链路
    + 无线链路
  + 帧：链路层的分组单元
    + 链路层负责将数据报封装成帧通过链路从一个节点传输到物理上相邻的下一个节点
+ 特别说明
  + 数据报在不同链路上可能由不同的链路层协议进行处理
  + 不同的链路层协议可能提供不同的服务

#### 链路层提供的服务
+ 成帧、链路访问
  + 将数据加上头部和尾部，封装成数据帧
  + 共享介质的信道访问
  + 帧头部用MAC地址标识源和目的（不同于IP地址）
+ 可靠传递
  + 很少用于误码率低的电路（光纤、双绞线链路）
  + 用于误码率高的链路（无线链路）
+ 流量控制
  + 在相邻的收发节点间限制流量
+ 差错检测
  + 信号衰减和电磁干扰噪声导致出错
  + 接收方检测到错误存在：给发送方发送信号要求重传或丢弃该数据帧
+ 差错纠正
  + 接收方检测和纠正帧中错误，不用重传
+ 半双工和全双工
  + 半双工时，链路两端的节点都能传输分组，但不能同时传输

#### 链路层的实现
+ 在每一台设备上（主机、交换机、路由器）
+ 链路层在“适配器”（网卡NIC）或者芯片上实现
+ 直接于主机的系统总线相连
+ 是硬件、软件和固件的结合体

#### 适配器通信
+ 发送方
  + 在一个帧内封装数据报
  + 增加差错检测位，可靠交付，流量检测等
+ 接收方
  + 查找错误，可靠交付，流量控制等
  + 取出数据报，交给网络层
+ 适配器是半自治单元
  + 帧的接收和发送、检错、丢弃均是自主进行
  + 向上提交数据时，需要节点干预
  + 最终受控于节点

## 差错检测和纠正技术
#### 因特网检查和
+ 发送方
  + 将数据段的内容作为16bit的整数序列
  + 校验和：累加求和，计算和的1的补码
  + 发送方将得到的校验和值放入PDU校验和字段
+ 接收方
  + 计算收到的数据段的校验和
  + 检查计算出的校验和于校验和字段中的值是否相同
    + NO——检测到错误
    + YES——没有错误
+ 特别注意
  + 仅用于TCP, UDP和IPv4

#### 循环冗余校验码
+ d比特的数据D
+ 选则r+1比特模式（生成多项式），表示为G
+ 目标：选则r个CRC比特，R，以便
  + <D, R>恰好额能够被G整除（模2计算）
  + 接收方一致G，用G去除<D, R>，若余数非0，则检测到错误
  + 能检测到所有少于r+1比特的错误
+ 在实践中被广泛应用（以太网、802.11 WiFi, ATM）

## 多路访问链路和协议
#### 两种链路
+ 点到点链路
  + PPP/以太网交换机和主机之间的点到点链路
+ 广播链路（共享线路或介质）
  + 传统以太网/802.11 无线LAN
  + 特点
    + 单个共享广播信道
    + 两个或多个节点同时传输：相互干扰
  + 碰撞：一个节点同时收到两个或多个信号

### 多址访问协议
+ 分布式算法巨野顶节点如何共享信道，如节点何时可以传输数据
+ 特别注意：有共享信道的通信（协商）需使用信道本身
  + 没有额外的信道来进行协调
+ 理想的多址访问协议需要满足
  + 假定：信道为速率为R b/s的广播信道
  + 当只有一个节点有数据发送时，该节点的吞吐量为R
  + 当M个节点有数据发送时，每个节点吞吐量为R/M
  + 全分散控制
    + 没有特定节点用于调整传输
    + 没有始终同步
  + 简单
+ 分类
  + 信道划分协议
    + 将信道划分成小的“片”（时隙、频率、编码）
    + 将“片”分配给节点使用
  + 随机访问协议
    + 信道没有被分隔，允许碰撞
    + 碰撞恢复
  + 轮流协议
    + 节点轮流传送，但数据量大的节点轮流更长实践

#### 信道划分协议
+ TDMA(Time Division Multiple Access)
  + 循环访问信道
  + 每个节点在每次循环中得到固定长度的时隙（时隙长度=传输单个分组实践）
  + 没有数据发送的时隙空闲
+ FDMA(Frequnce Division Multiple Access)
  + 信道按频谱分成若干频段
  + 每个节点分配固定频段
  + 在频段不用时该部分信道被闲置和浪费

#### 随机访问协议
+ 当节点有数据发送时
  + 以信道全部速率R传入
  + 没有主节点起协调作用
+ 两个或多个节点传送时——碰撞
+ 随机访问协议解决
  + 如何检测碰撞
  + 如何从碰撞中恢复（如：延时后重传）
+ 随机访问协议举例
  + ALOHA、时隙ALOHA
  + CSMA, CSMA/CD, CSMA/CA

##### ALOHA
+ Additive Link On-Line HAwaii system
+ 因群岛未知的散布，网络拓扑采用了星型结构
+ 为节省费用和易于组网，网络中各站点的通信采用了无线传输截至
+ 由于采用无线电信道，考虑到无法申请更多的频率点，因而所有站点都使用统一的频率通过主机交换信息

纯ALOHA的工作效率 $\frac{1}{2e} = 0.18$
$$
P(给定节点成功概率) = P(给定节点传送) * P(在[t0-1,t0]没其它节点传送) * P(在[t0, t0+1]没其它节点传送)
$$
$$
 = p * (1-p)^{N-1} * (1-p)^{N-1}
$$
$$
 = p * (1-p)^{2(N-1)}
$$

时隙ALOHA的工作效率 $\frac{1}{e} = 0.37$
$$ P(给定节点成功概率) = P(给定节点传送) * P(没有其它节点传送) $$
$$ = p * (1-p){N-1} $$

##### 载波监听CSMA
+ 传输前监听
  + 如果信道空闲，传送整个帧
  + 如果信道忙，推迟传送
+ 分类
  + 非坚持CSMA
    + 一旦监听到信道忙（即发送有其它站在发送数据），就不再坚持监听下去，而是根据协议的算法延迟一个随机的时间后重新再监听。若进行载波监听时发现信道空闲，则将准备好的帧发送出去
  + 时隙非坚持CSMA
    + 采用划分时隙的随机接入CSMA协议，协议规定只能再每个时隙开始时才能发送帧率
  + l坚持CSMA
    + 当一个站点要传送数据时，首先侦听信道，看是否有其它站点正在传送。如果信道正忙，它就持续等待直到它侦听到信道空闲时，便将数据送出。如发生冲突，站点就等待一个随机长的时间，然后重新开始
  + P坚持CSMA
    + 当一个站点要传送数据时，首先侦听信道，看是否有其它站点正在传送。如果信道正忙，它就持续等待直到它侦听到信道空闲时，以概率P发送数据，而以高铝(1-P)延迟一段时间$\tau$（网络中最远的端到端的传播时延），重新监听信道。若发生冲突，站点就等待一个随机长的时间，然后重新开始
+ 比较
  + 非坚持：不能充分利用信道刚刚转入空闲期的这段时间
  + l坚持：容易再上述时间产生冲突
  + P坚持：可以在一定程度上客服这些缺点，但却很难选则一个能用于各种通信量强度的P值，所以在实际网络中常选则l坚持

##### 带冲突检测的载波侦听CSMA/CD
+ 在短时间内碰撞被检测
  + 在有线LANs中比较容易：测量信号强度，比较收、发信号
  + 在无线LANs中比较困难：传输时接收器是关闭的
+ 碰撞后停止传输，减少信道浪费
+ 强化碰撞：
  + 当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送若干比特的认为干扰信号，以便让所有用户都直到现在已经发生了碰撞
+ 争用期
  + 最先发送数据帧的站，再发送数据帧后至多经过时间$2\tau$（两倍端到端往返时延）就可以知道发送的数据帧是否遭受了碰撞
  + 以太网的端到端往返时延$2\tau$成为争用期，或碰撞窗口
  + 经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞

#### 轮流协议
##### 与其它协议的比较
+ 信道划分协议
  + 在重负荷时
    + 共享信道有效、公平
  + 在轻负荷时效率低
    + 信道访问延时，即使只有一个活动节点，也只能分配到$\frac{1}{N}$的带宽
+ 随机访问协议
  + 轻负荷时效率高
    + 只有一个节点时，能充分利用信道
  + 在重负荷下
    + 碰撞的开销

##### 轮询协议
+ 主节点邀请从节点轮流传输
+ 关注
  + 轮询开销
  + 等待时间
  + 单点失效（主节点）

##### 令牌传递协议
+ 控制令牌一次通过各个节点
+ 令牌报文
+ 关注
  + 令牌的开销
  + 等待时间
  + 单点失效(token)

## 交换局域网
### MAC地址
+ 组成
  + 48bit
  + 前24bit由IEEE分配管理——OUI号
  + 后24bit由厂商自行分配
+ 作用
  + 在数据链路层标识每块网络适配器，使得能够在广播信道上寻址目标节点
  + MAC地址烧入网络适配器的ROM中，不可更改
+ 与IP地址的比较
  + MAC地址是平面地址，类似身份证号
  + IP地址是层次地址，类似邮政编码
  + 在不同的网络间迁移时，MAC地址不会改变
  + IP地址需要改变以适应新的网络配置

### 地址解析协议(ARP)
+ 目标
  + 根据目标的IP地址获取其MAC地址
+ ARP高速缓存
  + 局域网节点的IP/MAC地址映射
  + `<IP; MAC; TTL>`
  + TTL (Time To Live): 超过TTL的地址映射会被删除（一般20分钟）

##### 同一局域网内工作流程
+ 建立ARP请求包
+ 广播发送该ARP请求包
+ 目的IP的主机收到该ARP请求包，建立包含自己MAC地址的ARP应答包（注意，应答包和请求包的源、目标不一致。源始终是发出包的主机的）
+ 直接向目的IP的主机发送该ARP应答包
+ 目的IP更新ARP高速缓存

##### 局域网间工作流程
##### 互联网环境下的ARP

### 以太网
+ 类型
  + 总线式以太网
  + 交换式以太网
+ 帧结构
  + 数据字段：（46字节，1500字节）
  + 前同步码
    + 总共8字节，前7字节的格式为10101010，最后一个字节格式为10101011
    + 用于同步发送方与接收方始终
  + 地址：6字节
    + 若适配器收到以太网帧，目的地址为自己的MAC地址或广播地址（如ARP包），就将帧中的数据传递给网络层
    + 否则，适配器丢弃该帧
  + 类型：上层协议类型（大多为IP协议，也支持其它协议）
  + CRC：由接收方检查，若检测到错误，就将该帧丢弃
+ 提供的服务
  + 无连接服务：在送适配器和接收适配器之间不需要握手
  + 不可靠服务：接收适配器不发送确认帧或否认帧给发送方
    + 交给网络层的数据报可能存在间隙
    + 若应用使用TCP，间隙会被填充
    + 否则，应用就会看见间隙
+ 以太网使用的CSMA/CD
  + 特点
    + 没有时隙
    + 当适配器侦听到其它适配器在传输，它不传输帧，即载波侦听
    + 正在传输的适配器若检测到其它适配器也在传输，则它中止自己的传输，即碰撞检测
    + 在重新传输之前，适配器要等待一段随机时间，即随机回退
  + 算法
    + 适配器收到来种子网络层的数据报，创建帧
    + 若适配器检测到信道空闲，则开始传输帧；若检测到信道忙，就开始等待，直到信道空闲再开始传输该帧
    + 若适配器传输了整个帧而没有检测到其它适配器的传输，则该适配器完成该帧的传输
    + 若适配器在传输时检测到其它适配器也在传输，则停止传输，发送拥塞信号
    + 中止传输后，适配器进入指数回退阶段，在经历第m次碰撞后，适配器随机总$\{0, 1, 2, ..., 2^m-1\}$中选则K值。适配器在等待K*512比特时间后，返回第2步
  + 几个定义
    + 拥塞信号：用来确保所有传输者都能够检测到碰撞而传输的信号；长度为48bit
    + 比特时间：传输1比特所需时间。在10Mbps的以太网中，当K=1023时，等待时间大约为50ms
    + 指数回退算法
      + 目的：适配器重传时试图估计正确的负载
        + 重载：随机等待的时间可能会更长
      + 第一次碰撞：从{0, 1}中选则K；延迟是K*512比特传输时间
      + 第二次碰撞后：从{0, 1, 2, 3}中选则K
      + 第十次碰撞后：从{0, 1, ..., 1023}中选则K
  + 重要特性
    + 使用CSMA/CD协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）
    + 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性
    + 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率
  + 争用期长度
    + 以太网取51.2 us为争用期的长度
    + 对于10Mb/s以太网，在征用期间内可发送512bit，即64字节
    + 以太网在发送数据时，若前64字节没有发生碰撞，则后续的数据就不会发生碰撞
  + 最短有效帧长
    + 如果发生碰撞，就一定是在发送的前64字节之内
    + 由于一检测到碰撞就立即终止发送，这时已经发送出去的数据一定小于64字节
    + 以太网规定了最短有效帧长度为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧

### 信号编码
+ 曼彻斯特编码
  + 低电平到高电平为0，高电平到低电平为1
+ 差分曼切斯特编码
  + 第一个信号：
    + 中间电平从高到低，表示1
    + 中间电平从低到高，表示0
  + 后续信号
    + 每个区间内的头和下一个区间的头是相同电平，表示1
    + 每个区间内的头和下一个区间的头是相反电平，表示0

### 集线器（或转发器）互联
+ 主干集线器将LAN网段互联起来
+ 扩展了节点间的最大距离
+ 原先独立的网段碰撞域变成了一个大的碰撞域
+ 不能将10BaseT和100BaseT以太网互联

### 以太网交换机互联
+ 一种存储-转发设备，在MAC层实现LAN互联
+ 工作原理
  + 不断监听各接口是否有信号
  + 收到无差错的帧则缓存，反之将差错帧丢弃
  + 若所受帧的目的MAC地址属另一网段，则通过站表决定向何接口转发
  + 交换机不转发同一网段内通信的帧
  + 交换机不修改所转发的帧的源地址
+ 优势
  + 过滤通信量
  + 扩大了局域网的物理范围
  + 提高了可靠性
  + 可互连不同物理层、不同MAC子层何不同速率的局域网
+ 缺点
  + 由于要接收和转发，增加了时延
  + MAC子层没有流量控制功能，网络负荷重时，交换机缓存空间可能发生溢出，产生帧丢失现象
  + 出现广播风暴。交换机只适合用户少于几百个和通信量不太大的局域网，否则有时会因传播过多广播信息而产生网络拥塞
+ 和集线器的区别
  + 集线器指示将网络的覆盖距离简单延长，而且距离有限，具体实现在物理层；交换机不仅具有将LAN的覆盖距离延长的作用，而且理论上可做到无线延长，具体实现在MAC层
  + 集线器仅具有简单的信号整形和放大的功能；交换机则属于一种智能互联设备，它主要提供信号的存储/转发、数据过滤、路由选则等能力
  + 集线器仅是一种硬设备，而交换机既包括硬件又包括软件
+ 交换机的透明性
  + 局域网上的每个站并不知道所发送的帧将经过哪几个交换机，即交换机对各站来说是看不见的
+ 交换机选路原理
  1. 从接口x收到帧，有差错则丢弃，否则在站表中查找目的站MAC地址
  2. 找到有，则取出相应的接口d，转3，否则转5
  3. 如果所给MAC地址的接口d=x，则丢弃此帧（不需要转发），否则从接口d转发此帧；
  4. 转6
  5. 向除x以外的所有接口转发此帧（可保证找到目的站）
  6. 如源站不在站表中，则将源站MAC地址写入站表，等级该帧进入交换机的接口号和时间，设置计时器，然后转8，否则转7
  7. 更新计时器（由于网络拓扑经常变化，因此超时记录要删除，以反应最新状态）
  8. 等待新的数据帧，转1
+ 交换机存在的问题——兜圈子 
+ 解决方案——支撑树算法
  + 互连在一起的交换机彼此通信后，就能找出原来的网络拓扑的一个子集，在这个自己里整个连同的完了过中不存在回路。一旦支撑树确定了交换机，就会将某些接口断开，以确保从原来的拓扑得出一个支撑树
  + 支撑树算法选则一个交换机作为树的根，然后以最短路径为一句，找到树上的每一个节点
  + 为了让支撑树能反应网络拓扑的变化，每隔几秒钟每个交换机要广播其标识号，和它所直到的其它交换机
  + 缺点：互联局域网数目非常大时，支撑树算法可能花费很多时间
+ 以太网交换机VS路由器
  + 两者都是存储转发设备
    + 路由器：网络层设备（检查网络层头部）
    + 交换机：链路层设备
  + 路由器维护路由表，实现路由算法
  + 交换机维护交换表，实现MAC地址过滤、学习算法

| | 集线器 | 路由器 | 交换机 |
|:--|:--|:--|:--|
|流量隔离|无|有|有|
|即插即用|有|无|有|
|优化选路|无|有|无|
|直通交换|有|无|有|

### 虚拟局域网VLAN
+ 概念：虚拟局域网VLAN是指以软件方式来实现逻辑工作组划分与管理的一种网络工作组组建技术
+ 特征
  + 局域网交换机是组件虚拟局域网的核心设备
  + 组成逻辑工作组的各节点不受物理未知的限制，换言之，同一逻辑工作组的成员不一定要连在同一个物理网段上
  + 当一个节点从一个逻辑工作组转移到另一个逻辑工作组的时候，只需要通过软件设定，而不需要改变它在网络中的物理位置
+ 基于端口的虚拟局域网
  + 交换机端口被分成多组（由交换机管理软件完成），单个物理交换机可以被划分为多个虚拟交换机
+ 虚拟交换机的构建方式
  + 基于交换机接口号
  + 基于MAC地址
  + 基于IP地址
+ 功能：
  + 端口隔离：不同组的端口的帧仅仅能发送到本组内的其它端口（如果是基于交换机接口号划分的话）
  + 动态的成员管理：端口可以在VLAN之间动态分配
  + VLANS之间的转发：通过路由完成转发（就像使用单独的交换机一样）
+ 干线端口
  + 转发在多个物理交换机上的VLAN帧
    + 交换机之间在VLAN中转发的帧不是普通的802.1帧，必须要包含VLAN ID信息
    + 在802.lq协议中，干线端口转发的帧需要添加和删除额外的报头字段

## 回顾：Web页面请求的历程
+ 请求连接Internet所需的参数
  + 正在连接的笔记本需要获得IP地址、网关、DNS服务器等信息
1. 动态获取本机的IP地址
   1. DHCP请求依次进行UDP封装，IP封装，802.3以太网帧封装 
   2. 以太网帧向局域网发送广播（目的:FFFFFFFFFFFF），由运行DHCP server的网关路由器受到
   3. 路由器进行以太网帧解封、IP解封、UDP解封，得到DHCP请求
   4. DHCP server生成DHCP ACK报文，该报文包含客户端IP、掩码、网管你以及DNS服务器
   5. DHCP server进行封装，将数据帧通过局域网转发（交换机自学习），在客户端进行解封装
   6. DHCP client收到了DHCP ACK应答。客户端现在有了IP地址，直到了自己的名字、DNS服务器和网关
2. ARP（DNS之前，HTTP之前）——通过域名获得目标节点的IP
   + 在发送HTTP请求之前，需要直到目标域名的IP地址：DNS
   1. 客户端创建DNS请求，进行UDP封装，IP风窗，以太帧封装。在发送到网关路由器之前，需要直到路由器的接口MAC地址：采用ARP协议
   2. 客户端广播发送ARP请求，路由器收到以后，发送ARP应答，给出路由器接口的MAC地址
3. 使用DNS
   1. 客户端知道了网关路由器的MAC地址，可以发送包含DNS请求的数据帧了
   2. 包含DNS查询的IP数据报通过局域网交换机发到网关路由器
   3. 校园网的IP数据报路由转发到comcast网络（路由表由RIP, OSPF, IS-IS和/或BGP协议产生）的DNS服务器
   4. 多路分解到DNS server
   5. DNS server向客户端发送包含目标域名的IP的DNS应答
4. TCP连接
   1. 为了发送HTTP请求，客户端首先要创建到web服务器的TCP套接字
   2. TCP SYN报文（三次握手的第一步）域间路由到web server
   3. web server回应TCP SYNACK（三次握手的第二步）
   4. 客户端再次回应TCP ACK（三次握手的第三步）
   5. TCP连接建立
5. HTTP请求
   1. HTTP request发送到TCP socket
   2. 包含HTTP请求的IP数据报路由转发到目标域名地址
   3. web server进行HTTP reply响应（包含web page）
   4. 包含HTTP响应的IP数据报被路由转发回客户端
   5. web页面最终显示

# 无线网络和移动网络
## 概述
### 无线网络的元素
+ 无线主机
+ 基站
  + 典型的作用是用于连接无线网络
  + 负责向其覆盖范围内的主机发送和接收分组，在无线网络和无线主机之间起链路层中继的作用。如：蜂窝塔、802.11接入点
+ 无线链路
  + 典型的作用是用于连接无线主机和基站
  + 也可以用于骨干链路
  + 与链路访问相匹配的多址访问协议
  + 多种数据传输速率和传输距离

### 基础设施模式
+ 无线局域网可以分为两大类：有固定基础设施和自组网络(ad hoc网络)
+ 基础设施模式是指预先建立起来的、能够覆盖一定地理范围的一批固定基站
+ 移动主机通过基站接入有线网络
+ 切换：移动主机的移动可能会改变与之相关联的基站

##### 几个概念
+ 关联
  + 无线主机位于某个基站的无线通信覆盖范围内
  + 该主机使用该基站中继它与更大网络之间的数据
+ 切换
  + 当一台移动主机移动范围超出一个基站的覆盖范围而到达另一个基站的覆盖范围后，它将改变其接入更大网络的连接点
+ ad hoc网络
  + 一种没有固定基础设施的自组网络
  + 无基站
  + 节点（移动主机）仅仅能够在其覆盖范围内向其它节点传送数据
  + 节点之间相互通信组成的临时网络：在它们内部进行选路和地址分配

| | 单跳|多跳|
|:--|:--|:--|
|有基础设施|具有与较大的有限网络连接的基站（WiFi、蜂窝）|可能通过其它无线节点中继他们的通信：网状网络|
|无基础设施(ad hoc)|无基站，不连接到更大的网络（蓝牙、自组织网络）|没有基站，不连接到更大的网络，可能必须在其它几个节点之间中继报文：MANET（移动自组织网络），VANET（车载自组织网络）|

## 无线链路和网络特性
+ 无线链路的特征
  + 递减的信号强度
  + 来自其它源的干扰
  + 多径传播
  + -> 无线链路中的比特差错比有线链路中更为常见
+ 无线链路中差错处理
  + 采用CRC进行帧校验
  + 采用ARQ协议进行重传
+ 无线链路质量描述
  + 信号的传输会引入噪声，可能出现差错
  + 常用的两个描述链路质量的量
    + SNR——信噪比
    + BER——比特差错率
  + 信噪比与比特差错率的关系
    + 对于给定的调制方案，SNR越高，BER越低
    + 对于给定的SNR，具有较高比特传输率的调制技术将具有较高的BER
+ 隐藏终端问题
  + 存在障碍物
  + 信号衰减
+ 码多址访问CDMA
  + CDMA(Code Division Multiple Access)每个用户可以在同样的时间内用相同的频带进行通信。由于各用户使用经过特殊挑选的不同码类型，因此不会造成干扰。这种通信信号具有很高的抗干扰能力
  + 每个用户被指派一个唯一的m bit码片序列
  + 所有用户共享相同的频道，但每个用户用自己的“码片”序列对数据编码
    + 发送比特“1”时，发送指定给改站点的m bit码片序列
    + 发送比特“0”时，发送此m bit的二进制反码
    + 习惯上，将码片序列中的“0”写成“-1”，“1”写成“+1”
  + 允许多个用户宫村和发送信号，且互相干扰极小
  + 每一个站的码片序列各不相同，互相正交
    + 任何两个站点（如S和T站点）的码片向量规格化内积为0 $S \cdot T = \frac{1}{m} \sum s_it_i = 0$
    + 任何码片向量和自己的规格化内积为1 $S \cdot S = \frac{1}{m} \sum s_is_i = 1$
    + 任何码片向量和其反码的规格化内积为-1 $S \cdot (-S) = \frac{1}{m} \sum s_i (-s_i) = -1$

## Wi-Fi:802.11无线LAN
+ 802.11协议簇
  + 802.11b
    + 工作在不需要许可证的2.4~2.485GHz的无线频谱上
    + 最高数据速率11Mbps
    + 采用直接序列扩频(DSSS)
  + 802.11a
    + 频率范围:5.1~5.8GHz
    + 最高数据速率: 54Mbps
  + 802.11g
    + 2.4~2.485GHz范围
    + 最高数据速率54Mbps
  + 802.11n: 多天线
    + 2.4~2.485、5.1~5.8GHz范围
    + 单流最高数据速率150Mbps
    + 多流最高数据速率600Mbps
  + 802.11ac
    + 5.1~5.8GHz范围
    + 单流最高数据速率
      + 433Mbps@80MHz信道带宽
      + 866Mbps@160MHz信道带宽
    + 多流最高数据速率1.73Gbps、3.47Gbps

#### 第六代WiFi：802.11ax
+ 单流速率提升至1.2Gbps，8x8模式下提供高达9.6Gbps的传输速率
+ 支持较窄的子载波间隔以及增加的符号持续时间，更有利于确保信号的健壮性，令wifi覆盖至更远范围
+ 引入曾在4G LITE上使用的正交频分多址(OFDMA)技术，加之同时支持2.4GHz和5GHz频段，能创造出更多可用的数据通道，解决无线网络拥堵问题
+ 通过在多AP多用户并发场景中引入很多LTE领域的组网特性，让信号的抗干扰性大幅提升

### 802.11协议簇
+ 都使用CSMA/CA协议实现多路访问
+ 都可以用于固定基础设施模式和自组网络模式

### 802.11体系结构
+ 无线终端通过基站(AP)进行通信
+ 一个基站的服务范围
  + 基本服务集(BSS)
+ 基本服务集BSS包括
  + 无线终端 
  + 基站AP
  + Ad hoc模式下只有终端
+ 802.11b的信道划分
  + 2.4GHz-2.485GHz，共85MHz
  + 划分为11个部分重叠的信道集
  + 两个信道仅当中间相隔4个即以上的信道时，无重叠
  + 1、6、11三个信道不重叠，可同时工作

#### 802.11b中主机关联AP的过程
+ 每个AP周期性发送信标帧，包括AP的SSID和MAC
  + SSID: Service Set Identifier,服务集标识
+ 主机对11个信道进行扫描，获取所有可用的AP信标帧
+ 主机选则其中一个AP进行关联，加入其所属子网
+ 主机向关联AP发送DHCP发现报文，获取IP地址
+ 可能需要身份鉴别

#### WiFi：发送方的工作流程
1. 如果侦听到信道闲置了DIFS秒
2. 传输整个帧（无冲突检测）
3. 如果侦听到信道忙，则选则一个随机避退值作为定时器的定时时间，并在侦听信道空闲时递减该值
4. 定时到且信道空闲就发送数据
5. 如果收到确认，且站点要继续发送数据，则执行第一步
6. 如果没有收到确认(ACK)，则在更大范围内选取随机值，重复第3步
7. 如果帧收到则OK，等待SIFS秒后返回ACK
> ACK是必须的，因为隐蔽站问题

### 802.11的MAC协议
+ CSMA/CA
+ 802.11不采用冲突检测的原因：
  + 检测碰撞的能力要求站点具有同时发送和接收的能力
  + 802.11适配器，接收信号的强度可能远远小于发送信号的强度，从而被淹没，无法检测到
  + 如果一定要实现，则硬件代价会非常大
  + 另外，即使站点具备同时发送和监听的能力，也会由于隐蔽终端和衰减的问题，无法检测到所有的碰撞
+ 802.11采取碰撞避免而非碰撞检测

#### wifi的冲突避免
+ 思路：允许发送方“预约”信道而非随机访问：避免长的数据帧冲突
  + 发送方在发送数据帧之前首先使用CSMA协议发送一个短的请求发送RTS(request-to-send)帧给AP：
    + RTS也可能仍然会相互冲突（但时间很短）
  + AP广播一个允许发送CTS(clear-to-send)帧响应RTS
  + RTS被所有节点侦听到
    + 发送方发送数据帧
    + 其它站点推迟发送
> 使用短的预约帧可以完全避免数据帧发生冲突

##### 802.11 MAC帧格式
|2|2|6|6|6|2|4|0-2312|4|
|:-|:-|:-|:-|:-|:-|:-|:-|:-|
|帧控制|持续期|地址1|地址2|地址3|序号控制|地址4|有效载荷|CRC|
|||无线主机或AP接收该帧的MAC地址|无线主机或AP发送该帧的MAC地址|与AP连接的路由器接口的MAC地址| | 仅在ad hoc模式中使用| | |

##### WiFi帧首部的帧控制部分
|2|2|4|1|1|1|1|1|1|1|1|
|:-|:-|:-|:-|:-|:-|:-|:-|:-|:-|:-|
|协议版本|帧类型(RTS, CTS, ACK, 数据)|子类|到AP|从AP|更多标识|重试|功率管理|更多数据|WEP|Rsvd|

#### 802.11同一子网内的移动性
当H1既在AP1下又在AP2下，但AP1和AP2连接去同一个hub或交换机的时候，H1仍然在同一个IP子网中，IP地址也可能相同。

交换机：哪个AP与H1关联？  
-> 自学习  
交换机将看到来自H1的帧并“记住”能达到H1的哪个交换机端口

#### 802.11速率自适应
+ 基站和移动终端之间的传输速度会随着移动终端的移动和SNR的变化而智能的调整
  + 当终端向原理基站的方向移动时，SNR减小，BER增大
  + 当BER增大到一定程度时，将速率切换到一个较低水平来保障较低的BER

#### 功率管理
+ node-to-AP: “我将保持睡眠状态直到下一个信标帧”
  + AP直到不应当向这个节点发送任何帧
  + AP缓存所有需要发送给该节点的帧
  + 节点在下一个信标帧率前唤醒
+ 信标帧：包含了帧被缓存在AP中的节点的列表
  + 如果又帧，待发送节点会保持活动状态，请求这些帧，再转入睡眠状态。
  + 如果没有帧，重新进入睡眠状态直到下一个信标帧前

### 802.15——无线个人区域网
+ 半径小于10米
+ 取代电缆（鼠标，键盘，耳机）
+ 自组网：无固定基础设施
+ 802.15：从蓝牙技术规范演变而来
  + 2.4-2.5GHz ISM频段
  + 最大数据速率3Mbps
+ 主/从式：
  + 主设备轮询从设备
  + 批准从设备的传输请求

## 移动管理：原理
+ 移动节点的地址是否有必要始终保持不变
  + 取决于应用需要
+ 有哪些可用的有线基础设施的支持
  + 假设存在固定的基础设施让移动用户连接
    + 家庭的ISP网络
    + 办公室的无线接入网络
    + 沿高速公路的无线接入网络
  + 无固定的基础设施时
    + 自组织网络

### 详细实现
#### 术语
  + 归属网络：移动用户永久的“家”
  + 永久地址：归属网络中的地址，用它一定可以找到一定用户
  + 归属代理(HA)：当移动用户在远程时，代表移动节点执行移动管理功能的实体
+ 被访问网络：移动用户当前所在的网络
  + 外部代理：在被访问网络中帮助移动节点完成移动管理功能的实体
  + 永久地址(MA)：保持不变
  + 转交地址(COA)：在被访问网络中的地址
+ 通信者：希望与移动节点通信的实体

#### 两种解决办法
+ 让路由器处理：路由器通过通常的路由表交换方式向邻居通告移动节点的永久地址
  + 路由表指明移动用户的位置
  + 不需要对网络基础结构做出重大改变
  + 无法扩展到百万移动用户！！！
+ 让终端处理
  + 简介路由：通信者如果需要与移动用户通信，归属代理首先截获这些数据报，然后通过移动用户的COA将数据转发给外部代理，然后从该外部代理转发给移动用户
  + 直接路由：通信这获取移动用户的外部地址，然后直接将数据报发给移动用户

#### 移动节点的注册
移动用户进入被访问网络时向外部代理注册

外部代理向归属代理注册移动用户的COA：“这个移动用户在我的网络中”

#### 移动节点间的选路
+ 间接选路
  + 通信者将数据报指向移动用户的归属地址，并将数据报发送到网络中
  + 归属代理首先截获数据报，并将其封装在一个目的地址为COA的数据报内，然后将这些数据报转发给外部代理
  + 外部代理收到数据报，从中取出通信这的原始数据报，然后转发给移动用户
  + 移动用户直接响应通信者
+ 直接选路
  + 通信者向归属代理请求，然后收到移动用户的外部地址
  + 通信者将数据报发给外部代理
  + 外部代理收到数据报，然后转发给移动用户
  + 移动用户直接响应通信者
  + 问题：对通信者来说是非透明的：通信者必须从归属代理那里得到转交地址COA
    + 如果移动用户从一个被访问网络移动到另一个网络，通信者就找不到了
    + 解决方案：
      + 当用户移动到新的网络的时候，通信者仍然只用指向会话开始时被访问的外部网络，该网络的外部代理自己和新网络的外部代理之间建立联系并发送数据报

## 移动IP
支持移动性的因特网体系结构与协议统称为移动IP(RFC3344)
+ 要素
  + 归属代理、外部代理、外部代理注册转交地址、封装
+ 移动标准的组成
  + 代理发现
  + 向归属代理注册
  + 数据报的间接路由
